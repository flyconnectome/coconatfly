compound2regex <- function(x, prefix='/') {
  if(isFALSE(prefix))
    prefix=''
  x=gsub(",", "|", x)
  x=paste0(prefix, '(', x, ')')
  x
}

triple_connection_table <- function(hbtype, fwtype=hbtype, partners=c("inputs", "outputs"),
                                    threshold=1L, version=NULL, hbdetails=T,
                                    fwtypefield=c("hemibrain_type", "cell_type"),
                                    group='type') {
  partners=match.arg(partners, several.ok = T)
  if(length(fwtype)==1 && length(hbtype)==1 && isTRUE(fwtype==hbtype) && any(grepl(',', hbtype)))
    hbtype=compound2regex(hbtype)
  fwtypefield=match.arg(fwtypefield)
  if(length(partners)>1) {
    l=sapply(partners, simplify = F, function(p)
      triple_connection_table(hbtype, fwtype, partners=p, threshold = threshold, version=version, hbdetails = hbdetails, fwtypefield = fwtypefield, group=group))
    return(l)
  }
  stopifnot(isTRUE(hbdetails))
  hb=cf_partners(list(hemibrain=hbtype), partners = partners, threshold=threshold)[[1]]
  fw=cf_partners(list(flywire=fwtype), partners = partners, threshold = threshold)[[1]]
  stopifnot(isTRUE(version==fafbseg::flywire_connectome_data_version()))

  if(fwtypefield=='hemibrain_type')
    fw$type=fw$hemibrain_type
  compoundtypes <- unique(grep(",", fw$type, value = T))
  if(length(compoundtypes)>0) {
    # replace simple type in hb data with compound type
    for(ct in compoundtypes) {
      hb[grepl(compound2regex(ct, prefix=FALSE), hb$type),'type']=ct
    }
  }

  commoncols=intersect(colnames(hb), colnames(fw))
  x=do.call(rbind, list(hb[commoncols],fw[commoncols]))
  if(is.character(group)) {
    # right now we only support type as the grouping variable
    stopifnot(length(group)==1 && group=='type')
    xg <- x %>%
      dplyr::group_by(type) %>%
      dplyr::mutate(nd=dplyr::n_distinct(dataset)) %>%
      dplyr::ungroup()
    todrop <- xg %>%
      dplyr::filter(nd==1)
    message("Matching types across datasets. Dropping ",
            nrow(todrop), "/", nrow(x),
            " ", substr(partners,1,nchar(partners)-1),
            " partner types with total weight ", sum(todrop$weight), "/", sum(x$weight))
    x <- xg %>%
      dplyr::filter(nd>1) %>%
      dplyr::select(-nd)
  }
  x
}

triple_meta <- function(ids, version=fafbseg::flywire_connectome_data_version()) {
  ids <- fafbseg::flywire_ids(ids, integer64 = T)
  ishb <- ids<2^53

  fm=flytable_meta(ids, version = version)
  fm$instance=NA_character_
  colnames(fm)[colnames(fm)=='cell_type']='type'
  if(any(ishb)) {
    hbm <- neuprintr::neuprint_get_meta(ids[ishb])
    hbm$side=stringr::str_match(hbm$name, "_([LR])")[,2]
    hbm$side=ifelse(is.na(hbm$side), 'hb', paste0("hb", hbm$side))
    fm[ishb, c("type", "instance", "side")]=hbm[c("type", "name", "side")]
  }
  fm
}

#' Cosine cluster across hemibrain and flywire
#'
#' @details Note that for bilateral neurons it may work better to use either
#'   input partners or output partners but not both.
#'
#' @param x Hemibrain ids or a dataframe generated by
#'   \code{triple_connection_table}
#' @param fwtype Optional flywire ids interpreted by \code{flywire_ids} function
#' @param version Connectome data dump version. See
#'   \code{\link{flywire_connectome_data_version}} for details.
#' @param ... Additional arguments to heatmap
#' @param threshold Minimum connection weight to be included when finding
#'   partners
#' @param partners Whether to use output or input partners for clustering.
#'   Default now uses both.
#' @param labRow A character vector defining labels for the rows of the
#'   resultant heatmap
#' @param heatmap A logical indicating whether or not to plot the heatmap
#'   \emph{OR} a function to plot the heatmap whose argument names are
#'   compatible with \code{stats::\link{heatmap}}. \code{gplots::heatmap.2} is a
#'   good example.
#' @param nas What to do with rows/columns with NAs when computing cosine
#'   matrix. Dropping may be more mathematically satisfactory but eliminates
#'   neurons from the comparison, so the default is to set NA elements to do 0
#'   similarity.
#' @param group What column to use for grouping partners.
#' @param method the clustering method. See \code{\link{hclust}} for details.
#' @param interactive When \code{TRUE} returns a shiny-based interactive heatmap
#'
#' @return A list as returned by \code{\link{heatmap}}
#' @export
#'
#' @examples
#' \donttest{
#' # AOTU063 should be separated into two subtypes.
#' # Very clear based on output clustering and also some small morphological differences.
#' triple_cosine_plot('AOTU063', partners = 'o')
#'
#' # LAL074/LAL084 are the same type.
#' # Were incorrectly split due to annotation into separate hemibrain CBFs
#' # note that the compound type 'LAL074,LAL084' will be used to find flywire
#' # neurons but expanded to the regex "(LAL074|LAL084)" in order to find
#' # both hemibrain types
#' triple_cosine_plot('LAL074,LAL084', partners = 'i')
#' }
#' @importFrom fafbseg flywire_connectome_data_version flytable_meta flywire_partner_summary2
triple_cosine_plot <- function(x, fwtype=x, version=NULL, ..., threshold=5,
                               partners = c("outputs", "inputs"),
                               labRow='{type}_{side}',
                               group='type',
                               heatmap=TRUE,
                               interactive=FALSE,
                               nas=c('zero','drop'),
                               method=c("ward.D", "single", "complete", "average",
                                        "mcquitty", "median", "centroid", "ward.D2")) {
  method=match.arg(method)
  partners=match.arg(partners, several.ok = T)
  if(is.null(version))
    version=flywire_connectome_data_version()
  if(!is.data.frame(x))
    x=triple_connection_table(x, fwtype, partners = partners, threshold = threshold, version = version, group=group)

  cm <- triple_cosine_matrix(x, partners = partners, group=group, nas=nas)

  if(is.character(labRow) && length(labRow)==1 && any(grepl("\\{", labRow))) {
    tm=triple_meta(colnames(cm))
    labRow <- glue::glue(labRow, .envir = tm)
  }
  if(interactive) {
    try(cv <- requireNamespace('coconat', versionCheck=list(op='>', version='0.1.0')))
    if(inherits(cv, 'try-error'))
      stop("Please install/update suggested package coconat.\n",
           "natmanager::install(pkgs = 'coconat')\n","is a good way to do this")
  }
  coconat:::cosine_heatmap(cm, interactive = interactive, labRow = labRow,
                           method = method, heatmap=heatmap, ...)
}

triple_cosine_matrix <- function(x, partners, nas, group='type') {
  if(is.data.frame(x)) {
    if(length(partners)>1)
      stop("If you provide a data.frame as input you must specify just one of inputs/outputs")
    x=list(x)
    names(x)=partners
  }
  # a bit of a shuffle because c(NULL, <integer64>) removes the class
  empty_ids=bit64::integer64()
  ids=unique(c(
    if(is.null(x$outputs$pre_id)) empty_ids else x$outputs$pre_id,
    if(is.null(x$inputs$post_id)) empty_ids else x$inputs$post_id
  ))

  cm=list()
  if('outputs' %in% partners) {
    oam <- coconat::partner_summary2adjacency_matrix(
      x[['outputs']],
      inputcol = 'pre_id',
      outputcol = group,
      inputids = ids)
    cm[['cout']] = coconat::cosine_sim(oam, transpose = T)
    cm[['wout']]=sum(x[['outputs']]$weight)
  }
  if('inputs' %in% partners) {
    iam <- coconat::partner_summary2adjacency_matrix(
      x[['inputs']],
      inputcol = group, outputcol = 'post_id', outputids = ids)
    cm[['cin']] = coconat::cosine_sim(iam, transpose = F)
    cm[['win']]=sum(x[['inputs']]$weight)
  }
  cm <- coconat::prepare_cosine_matrix(cm, partners = partners, action=nas)
  cm
}

separate_ids <- function(ids, integer64 = TRUE) {
  ids <- fafbseg::flywire_ids(ids, integer64 = T)
  ishb <- ids<2^53
  # will convert to char if necessary
  ids <- fafbseg::flywire_ids(ids, integer64 = integer64)
  list(fw=ids[!ishb], hb=ids[ishb])
}
